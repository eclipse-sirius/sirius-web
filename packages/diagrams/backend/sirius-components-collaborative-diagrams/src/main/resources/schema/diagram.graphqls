extend type Subscription {
  diagramEvent(input: DiagramEventInput!): DiagramEventPayload!
}

input DiagramEventInput {
  id: ID!
  editingContextId: ID!
  diagramId: ID!
}

union DiagramEventPayload =
  ErrorPayload
  | DiagramRefreshedEventPayload

type DiagramRefreshedEventPayload {
  id: ID!
  diagram: Diagram!
  cause: RefreshCause!
  referencePosition: ReferencePosition
}

enum RefreshCause {
  refresh
  layout
}

type ReferencePosition {
  parentId: ID
  position: Position!
}

type Diagram implements Representation {
  id: ID!
  metadata: RepresentationMetadata!
  targetObjectId: ID!
  size: Size!
  position: Position!
  nodes: [Node!]!
  edges: [Edge!]!
  layoutData: DiagramLayoutData!
}

type DiagramLayoutData {
  nodeLayoutData: [NodeLayoutData!]!
}

type NodeLayoutData {
  id: ID!
  position: Position!
  size: Size!
  resizedByUser: Boolean!
  minimumWidth: Int!
}

enum ViewModifier {
  Normal
  Faded
  Hidden
}

enum UserResizableDirection {
  BOTH
  HORIZONTAL
  VERTICAL
  NONE
}

type Node {
  id: ID!
  insideLabel: InsideLabel
  outsideLabels: [OutsideLabel!]!
  descriptionId: ID!
  type: String!
  targetObjectId: String!
  targetObjectKind: String!
  targetObjectLabel: String!
  size: Size!
  position: Position!
  state: ViewModifier!
  pinned: Boolean!
  style: INodeStyle!
  childrenLayoutStrategy: ILayoutStrategy
  borderNodes: [Node!]!
  childNodes: [Node!]!
  defaultWidth: Int
  defaultHeight: Int
  labelEditable: Boolean!
}

type FreeFormLayoutStrategy {
  kind: String!
}

type ListLayoutStrategy {
  kind: String!
  areChildNodesDraggable: Boolean!
  topGap: Int!
  bottomGap: Int!
  growableNodeIds: [ID!]!
}

union ILayoutStrategy = FreeFormLayoutStrategy | ListLayoutStrategy

type Label {
  id: ID!
  text: String!
  type: String!
  style: LabelStyle!
  alignment: Position!
  position: Position!
  size: Size!
}

type InsideLabel {
  id: ID!
  text: String!
  insideLabelLocation: InsideLabelLocation!
  style: LabelStyle!
  isHeader: Boolean!
  displayHeaderSeparator: Boolean!
  overflowStrategy: LabelOverflowStrategy!
  textAlign: LabelTextAlign!
}

enum InsideLabelLocation {
  TOP_CENTER
  TOP_LEFT
  TOP_RIGHT
  BOTTOM_CENTER
  BOTTOM_LEFT
  BOTTOM_RIGHT
  MIDDLE_CENTER
  MIDDLE_LEFT
  MIDDLE_RIGHT
}

enum LabelOverflowStrategy {
  NONE
  WRAP
  ELLIPSIS
}

enum LabelTextAlign {
  LEFT
  RIGHT
  CENTER
  JUSTIFY
}

type OutsideLabel {
  id: ID!
  text: String!
  outsideLabelLocation: OutsideLabelLocation!
  style: LabelStyle!
  overflowStrategy: LabelOverflowStrategy!
  textAlign: LabelTextAlign!
}

enum OutsideLabelLocation {
  BOTTOM_BEGIN
  BOTTOM_MIDDLE
  BOTTOM_END
}

type LabelStyle {
  bold: Boolean!
  color: String!
  fontSize: Int!
  iconURL: [String!]!
  italic: Boolean!
  strikeThrough: Boolean!
  underline: Boolean!
  borderColor: String!
  borderRadius: Int!
  borderSize: Int!
  borderStyle: LineStyle!
  background: String!
}

union INodeStyle = ImageNodeStyle | IconLabelNodeStyle | RectangularNodeStyle

type ImageNodeStyle {
  imageURL: String!
  borderColor: String!
  borderRadius: Int!
  borderSize: Int!
  borderStyle: LineStyle!
  positionDependentRotation: Boolean!
}

type IconLabelNodeStyle {
  background: String!
}

type RectangularNodeStyle {
  borderColor: String!
  borderRadius: Int!
  borderSize: Int!
  borderStyle: LineStyle!
  background: String!
}

enum LineStyle {
  Dash
  Dash_Dot
  Dot
  Solid
}

type Edge {
  id: ID!
  descriptionId: ID!
  type: String!
  beginLabel: Label
  centerLabel: Label
  endLabel: Label
  sourceId: ID!
  targetId: ID!
  targetObjectId: String!
  targetObjectKind: String!
  targetObjectLabel: String!
  state: ViewModifier!
  style: EdgeStyle!
  routingPoints: [Position]!
  sourceAnchorRelativePosition: Ratio!
  targetAnchorRelativePosition: Ratio!
  centerLabelEditable : Boolean!
}

type EdgeStyle {
  color: String!
  lineStyle: LineStyle!
  size: Int!
  sourceArrow: ArrowStyle!
  targetArrow: ArrowStyle!
}

enum ArrowStyle {
  Diamond
  FillDiamond
  InputArrow
  InputArrowWithDiamond
  InputArrowWithFillDiamond
  InputClosedArrow
  InputFillClosedArrow
  None
  OutputArrow
  OutputClosedArrow
  OutputFillClosedArrow
  Circle
  FillCircle
  CrossedCircle
  ClosedArrowWithVerticalBar
  ClosedArrowWithDots
}

type Ratio {
  x: Float!
  y: Float!
}

type Position {
  x: Float!
  y: Float!
}

type Size {
  height: Float!
  width: Float!
}

type Palette {
  id: ID!
  tools: [Tool]!
  toolSections: [ToolSection]!
}

type ToolSection {
  id: ID!
  label: String!
  iconURL: [String!]!
  tools: [Tool]!
}

interface Tool {
  id: ID!
  label: String!
  iconURL: [String!]!
}

type SingleClickOnDiagramElementTool implements Tool {
  id: ID!
  label: String!
  iconURL: [String!]!
  appliesToDiagramRoot: Boolean!
  selectionDescriptionId: String
  targetDescriptions: [DiagramElementDescription!]!
}

type SingleClickOnTwoDiagramElementsTool implements Tool {
  id: ID!
  label: String!
  iconURL: [String!]!
  candidates: [SingleClickOnTwoDiagramElementsCandidate]!
}

type SingleClickOnTwoDiagramElementsCandidate {
  sources: [NodeDescription!]!
  targets: [NodeDescription!]!
}

type DiagramDescription implements RepresentationDescription {
  id: ID!
  label: String!
  autoLayout: Boolean!
  arrangeLayoutDirection: ArrangeLayoutDirection!
  nodeDescriptions: [NodeDescription!]!
  childNodeDescriptionIds: [ID!]!
  edgeDescriptions: [EdgeDescription!]!
  palette(diagramElementId: ID!): Palette!
  connectorTools(sourceDiagramElementId: ID!, targetDiagramElementId: ID!): [Tool!]!
  dropNodeCompatibility: [DropNodeCompatibilityEntry!]!
  initialDirectEditElementLabel(labelId: ID!): String!
  debug: Boolean
}

enum ArrangeLayoutDirection {
  UNDEFINED
  RIGHT
  DOWN
  LEFT
  UP
}

type DropNodeCompatibilityEntry {
  droppedNodeDescriptionId: ID!
  droppableOnDiagram: Boolean!
  droppableOnNodeTypes: [ID!]!
}

interface DiagramElementDescription {
  id: ID!
  synchronizationPolicy: SynchronizationPolicy!
}

type NodeDescription implements DiagramElementDescription {
  id: ID!
  synchronizationPolicy: SynchronizationPolicy!
  childNodeDescriptionIds: [ID!]!
  borderNodeDescriptionIds: [ID!]!
  userResizable: UserResizableDirection!
  keepAspectRatio: Boolean!
}

type EdgeDescription implements DiagramElementDescription {
  id: ID!
  synchronizationPolicy: SynchronizationPolicy!
  sourceNodeDescriptions: [NodeDescription!]!
  targetNodeDescriptions: [NodeDescription!]!
}

enum SynchronizationPolicy {
  SYNCHRONIZED
  UNSYNCHRONIZED
}

extend type Mutation {
  arrangeAll(input: ArrangeAllInput!): ArrangeAllPayload!
  deleteFromDiagram(input: DeleteFromDiagramInput!): DeleteFromDiagramPayload!
  editLabel(input: EditLabelInput!): EditLabelPayload!
  invokeSingleClickOnDiagramElementTool(input: InvokeSingleClickOnDiagramElementToolInput!): InvokeSingleClickOnDiagramElementToolPayload!
  invokeSingleClickOnTwoDiagramElementsTool(input: InvokeSingleClickOnTwoDiagramElementsToolInput!): InvokeSingleClickOnTwoDiagramElementsToolPayload!
  updateNodeBounds(input: UpdateNodeBoundsInput!): UpdateNodeBoundsPayload!
  updateNodePosition(input: UpdateNodePositionInput!): UpdateNodePositionPayload!
  dropOnDiagram(input: DropOnDiagramInput!): DropOnDiagramPayload!
  dropNode(input: DropNodeInput!): DropNodePayload!
  updateEdgeRoutingPoints(input: UpdateEdgeRoutingPointsInput!): UpdateEdgeRoutingPointsPayload!
  reconnectEdge(input: ReconnectEdgeInput!): ReconnectEdgePayload!
  hideDiagramElement(input: HideDiagramElementInput!): HideDiagramElementPayload!
  fadeDiagramElement(input: FadeDiagramElementInput!): FadeDiagramElementPayload!
  updateCollapsingState(input: UpdateCollapsingStateInput!): UpdateCollapsingStatePayload!
  pinDiagramElement(input: PinDiagramElementInput!): PinDiagramElementPayload!
  layoutDiagram(input: LayoutDiagramInput!): LayoutDiagramPayload!
}

input DropNodeInput {
  id: ID!
  editingContextId: ID!
  representationId: ID!
  droppedElementId: ID!
  targetElementId: ID
  x: Float!
  y: Float!
}

input ArrangeAllInput {
  id: ID!
  editingContextId: ID!
  representationId: ID!
}

union ArrangeAllPayload = SuccessPayload | ErrorPayload

input DeleteFromDiagramInput {
  id: ID!
  editingContextId: ID!
  representationId: ID!
  nodeIds: [ID!]!
  edgeIds: [ID!]!
  deletionPolicy: DeletionPolicy!
}

enum DeletionPolicy {
  SEMANTIC
  GRAPHICAL
}

union DeleteFromDiagramPayload = ErrorPayload | DeleteFromDiagramSuccessPayload

type DeleteFromDiagramSuccessPayload {
  id: ID!
  diagram: Diagram!
  messages: [Message]!
}

input EditLabelInput {
  id: ID!
  editingContextId: ID!
  representationId: ID!
  labelId: ID!
  newText: String!
}

union EditLabelPayload = ErrorPayload | EditLabelSuccessPayload

type EditLabelSuccessPayload {
  id: ID!
  diagram: Diagram!
  messages: [Message]!
}

input InvokeSingleClickOnTwoDiagramElementsToolInput {
  id: ID!
  editingContextId: ID!
  representationId: ID!
  toolId: ID!
  diagramSourceElementId: ID!
  diagramTargetElementId: ID!
  sourcePositionX: Float!
  sourcePositionY: Float!
  targetPositionX: Float!
  targetPositionY: Float!
}

union InvokeSingleClickOnTwoDiagramElementsToolPayload =
  ErrorPayload
  | InvokeSingleClickOnTwoDiagramElementsToolSuccessPayload

type InvokeSingleClickOnTwoDiagramElementsToolSuccessPayload {
  id: ID!
  newSelection: WorkbenchSelection
  messages: [Message]!
}

input InvokeSingleClickOnDiagramElementToolInput {
  id: ID!
  editingContextId: ID!
  representationId: ID!
  selectedObjectId: String
  diagramElementId: ID!
  startingPositionX: Float!
  startingPositionY: Float!
  toolId: ID!
}

union InvokeSingleClickOnDiagramElementToolPayload =
  ErrorPayload
  | InvokeSingleClickOnDiagramElementToolSuccessPayload

type InvokeSingleClickOnDiagramElementToolSuccessPayload {
  id: ID!
  newSelection: WorkbenchSelection
  messages: [Message]!
}

input UpdateNodeBoundsInput {
  id: ID!
  editingContextId: ID!
  representationId: ID!
  diagramElementId: ID!
  newHeight: Float!
  newPositionX: Float!
  newPositionY: Float!
  newWidth: Float!
}

union UpdateNodeBoundsPayload = ErrorPayload | UpdateNodeBoundsSuccessPayload

type UpdateNodeBoundsSuccessPayload {
  id: ID!
  diagram: Diagram!
}

input UpdateNodePositionInput {
  id: ID!
  editingContextId: ID!
  representationId: ID!
  diagramElementId: ID!
  newPositionX: Float!
  newPositionY: Float!
}

union UpdateNodePositionPayload =
  ErrorPayload
  | UpdateNodePositionSuccessPayload

type UpdateNodePositionSuccessPayload {
  id: ID!
  diagram: Diagram!
}

input DropOnDiagramInput {
  id: ID!
  editingContextId: ID!
  representationId: ID!
  diagramTargetElementId: ID
  objectIds: [String!]!
  startingPositionX: Float!
  startingPositionY: Float!
}

union DropOnDiagramPayload = ErrorPayload | DropOnDiagramSuccessPayload

type DropOnDiagramSuccessPayload {
  id: ID!
  diagram: Diagram!
  messages: [Message]!
}

union DropNodePayload = ErrorPayload | SuccessPayload

input UpdateEdgeRoutingPointsInput {
  id: ID!
  editingContextId: ID!
  representationId: ID!
  diagramElementId: ID!
  routingPoints: [PositionInput]!
}

input PositionInput {
  x: Float!
  y: Float!
}

union UpdateEdgeRoutingPointsPayload = ErrorPayload | SuccessPayload

enum ReconnectEdgeKind {
  SOURCE
  TARGET
}

input ReconnectEdgeInput {
  id: ID!
  editingContextId: ID!
  representationId: ID!
  edgeId: String!
  newEdgeEndId: String!
  reconnectEdgeKind: ReconnectEdgeKind!
  newEdgeEndPosition: PositionInput!
}

union ReconnectEdgePayload = ErrorPayload | SuccessPayload

input HideDiagramElementInput {
  id: ID!
  editingContextId: ID!
  representationId: ID!
  elementIds: [ID!]!
  hide: Boolean!
}

union HideDiagramElementPayload = ErrorPayload | SuccessPayload

input FadeDiagramElementInput {
  id: ID!
  editingContextId: ID!
  representationId: ID!
  elementIds: [ID!]!
  fade: Boolean!
}

union FadeDiagramElementPayload = ErrorPayload | SuccessPayload

input PinDiagramElementInput {
  id: ID!
  editingContextId: ID!
  representationId: ID!
  elementIds: [ID!]!
  pinned: Boolean!
}


union PinDiagramElementPayload = ErrorPayload | SuccessPayload

input UpdateCollapsingStateInput {
  id: ID!
  editingContextId: ID!
  representationId: ID!
  diagramElementId: ID!
  collapsingState: CollapsingState!
}

enum CollapsingState {
  COLLAPSED
  EXPANDED
}

union UpdateCollapsingStatePayload = ErrorPayload | SuccessPayload

input LayoutDiagramInput {
  id: ID!
  editingContextId: ID!
  representationId: ID!
  diagramLayoutData: DiagramLayoutDataInput!
}

input DiagramLayoutDataInput {
  nodeLayoutData: [NodeLayoutDataInput!]!
}

input NodeLayoutDataInput {
  id: ID!
  position: PositionInput!
  size: SizeInput!
  resizedByUser: Boolean!
  minimumWidth: Int!
}

input SizeInput {
  height: Float!
  width: Float!
}

union LayoutDiagramPayload = ErrorPayload | SuccessPayload
