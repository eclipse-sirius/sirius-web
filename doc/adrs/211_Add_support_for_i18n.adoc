= ADR-211 - Add the support for i18n

== Context

We have more and more users who English is not the native language.
Adding the support for internationalization could ease their use of Sirius-Web.

== State of the art

[NOTE]
====
I wrote this State of the art without knowing nothing about i18n in the frontend.
I based everything only on reading framework documentation, document making comparison between the tools.
====

Since we already are using i18n in our backend with Spring, I will only address the frontend part of the i18n.
However we have to discuss in another ADR about API to include in AQL Service to ease the support for i18n in AQL expression for View DSL.

With the variety of existing language comes issues for each specific language.
For that, the https://cldr.unicode.org/[Unicode CLDR] has gathered data about locales.
The https://icu.unicode.org/[ICU] project propose a set of C++ and Java libraries using the CLDR.
Even if ICU is for C++ and Java initially a lot of JavaScript libraries are using concept of ICU for example the syntax for plural the "ICU Message Syntax".

[NOTE]
====
I initially start to compare the three most used i18n JavaScript frameworks (https://react.i18next.com/[React i18next], https://formatjs.github.io/[react-intl (Format Js)] and https://github.com/lingui/js-lingui[Lingui Js]) but it appears that `React i18next` can do a lot of what others do.
Even if it does not use the ICU syntax at first, a module can provide its support.
Even if it bases its flow using key to reference translation in locale files (which may not be developer friendly), the ICU module seems to be able to create locale files without using key thanks to macros.
====

=== Glossary

CLDR: Common Locale Data Repository
ICU: International Components for Unicode

== Decision

We will use https://react.i18next.com/[React i18next] as the i18n JavaScript frontend framework.

Anywhere a String is displayed in the UI we will need to either define an entry in the locale file and use it with the `useTranslation` hook, or use Macro componants like `Trans` or `Plural`.

[NOTE]
====
Yet, I don't know if we could use both approach at the same time, if it will be difficult to maintain both if one is better than the other
It will depend on the type of String we have to internationalize.
====

==== Example using key

In `TreeDescriptionsMenu.tsx`:

[source, jsx]
----
const TreeDescriptionsMenu = () => {
  const { t } = useTranslation('siriusWebApplicationWorkbenchViewsExplorer', { keyPrefix: 'view' });

  return (
    <div>
      <IconButton
          data-testid={`tree-descriptions-menu-icon`}
          title={t('title')}
          aria-label={t('title')}
          aria-controls="tree-descriptions-menu"
          aria-haspopup="true"
          ref={anchorRef}
          color="inherit"
          size="small"
          onClick={handleToggle}>
          <AccountTreeIcon color={open ? 'disabled' : 'inherit'} />
        </IconButton>
    </div>
  );
}

----

In `sirius-web-application/src/locales/en.json`
[source, json]
----
{
  "siriusWebApplicationWorkbenchViewsExplorer": {
    "view": {
      "title": "Explorers"
    }
  }
}
----

In `sirius-web-application/src/locales/fr.json`
[source, json]
----
{
  "siriusWebApplicationWorkbenchViewsExplorer": {
    "view": {
      "title": "Explorateurs"
    }
  }
}
----

==== Example using macro

In `DetailsView.tsx`, if we were displaying the number of selected element we could write something like

[source, jsx]
----

const DetailsView = () => {

  content = (
    <div className={class.selection}>
      <Typography variant="subtitle2"><Plural
        count={selection.entries.length}
        $0={<Trans>No object selected</Trans>}
        one={<Trans>There is # object in the selection</Trans>}
        other={<Trans>There are # items in the selection</Trans>}
      />
    </div>
  );
};
----

In `sirius-web-application/src/locales/en.json`
[source, json]
----
{
  "{selection.entries.length, plural,  =0 {No object selected} one {There is # object in the selection} other {There are # items in the selection}}": "{selection.entries.length, plural,  =0 {No object selected} one {There is # object in the selection} other {There are # items in the selection}}"
}
----

In `sirius-web-application/src/locales/fr.json`
[source, json]
----
{
  "{selection.entries.length, plural,  =0 {No object selected} one {There is # object in the selection} other {There are # items in the selection}}": "{selection.entries.length, plural,  =0 {Aucun objet n'est sélectionné} one {Il y a # object sélectionné} other {Il y a # objets sélectionnés}}"
}
----

NOTE: In the json file we may replace the key by an ID instead of the long string probably generated by a tool.

== Consequences

All Strings shown to the user should now use the i18n framework.
Downstream project will be able to reuse that framework if they want to have a coherent application.
It may require to update our check in the CI to ensure that developers have not forgotten to generate or update locale files.

== Status

WIP.