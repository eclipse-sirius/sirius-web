= ADR-209 - Add a way to customize the tree displayed to select the candidates in a Reference Widget

== Context

The reference widget has originaly been designed for the specific use case of editing a single EMF `EReference`, and thus only offered limited customizability.
Over the time, several mechanisms have been introduced to make it more configurable.
However, one part that is currently still hard-coded is the definition of the _tree_ that is presented to the end-user for selecting new value(s) when editing the reference.

Currently there are only two, hard-coded, tree descriptions that can be used, and the choice between them is itself hard-coded in the frontend:

* In the `CreateModal` (used to allow the user to select the parent of the element to create), we always use the `ModelBrowserDescriptionProvider.CONTAINER_DESCRIPTION_ID`
* In either the `BrowseModal.tsx` or `TransferModal.tsx` (used to select an existing object to set/add in a reference), we always use `ModelBrowserDescriptionProvider..REFERENCE_DESCRIPTION_ID`.

This choice should be made more open, with each widget being allowed to indicate a specific `TreeDescription` to use, among the ones available on the backend.

== Decision

Internally the current implementation works like this:

* On the frontend, `ModelBrowserTreeView` accepts a `leafType` property, which can only be  `'containment'` (used in `CreateModal`) or `'reference'` (used in `BrowseModal` and `TransferModal`).
* This `leafType` is used to build the tree id to which we subscribe in `ModelBrowserTreeView`, which will thus (currently) always start with either `'modelBrowser://container'` or `'modelBrowser://reference'`.
* On the backend, when receiving a subscription request, `ModelBrowserEventProcessorFactory` only handles these two specific prefixes to select one of the two hard-coded `ModelBrowserDescriptionProvider.CONTAINER_DESCRIPTION_ID` and `ModelBrowserDescriptionProvider.REFERENCE_DESCRIPTION_ID`.

To make this more open and flexible, we allow a reference widget to specify others values than `'reference'` and `'containment'` to identify the browser definition to use.
Technically, the value of this new `browserId` attribute could be the actual `UUID` of any `TreeDescription` registered in the editing context.
In practice, when configuring a widget from the View DSL, we can not expect studio makers to know and use raw `UUID`, so we need a way to denote custom model browsers from symbolic names (similar to the existing `'container'` and `'reference'`).

For this we will introduce a new interface `IModelBrowserProvider`:

[source,java]
----
package org.eclipse.sirius.components.collaborative.browser.api;

public record ModelBrowser(String modelBrowserId, String treeDescriptionId) { }

public interface IModelBrowserProvider {
    List<ModelBrowser> getModelBrowsers(IEditingContext editingContext);
}
----

Instead of referencing these two hard-coded definitions, `ModelBrowserEventProcessorFactory` will instead find the appropriate `TreeDescription` to use with the list of registered `IModelBrowserProvider`.

More precisely, from a `descriptionId` of the form `modelBrowser://BROWSER_ID?PARAMS`, `ModelBrowserEventProcessorFactory` will find the `IModelBrowserProvider` with the mentioned browserId, and use the corresponding `TreeDescription` (which must have been registered inside the editing context).

The existing browser tree definitions used for `'modelBrowser://container'` and `'modelBrowser://reference'` will be re-implemented as just two default implementations of this new interface.
Because `ModelBrowserEventProcessorFactory` will no longer have hard-coded knowledge about these default implementations, they will be moved out of the `sirius-components-collaborative-browser` project and into `sirius-web-application` (package `org.eclipse.sirius.web.application.browser`).

Finally, the `ReferenceWidget` will get a new (optional) attribute named `browserId` (a string).
It will be computed at render time from a `WidgetDescription.browserIdProvider` (a `Function<VariableManager, String>`), itself exposed as a `browserIdExpression` in the View version of `WidgetDescription`

In the frontend, this `browserId`, if present, will be used instead of `'reference'` as `leafType` (this prop will be also be renamed into `browserId`).

If a widget does not specify a custom `browserId`, we will fallback to the current value, `'reference'`.

=== Usage

To use the new mechanism, a downstream application will need to:

1. Provide a service implementing `IModelBrowserMetadataProvider` with a custom name (say `myCustomBrowser`) and corresponding tree description.
2. Register the corresponding tree description inside the editing context (for example using a `IEditingContextRepresentationDescriptionProvider`).
3. Configure the reference widgets that should use this browser with `browserIdExpression = "aql:'myCustomBrowser'"`.

The first two steps can only be performed by developers, but once a particular custom model browser is made available inside a given application/deployment, studio makers can decide on a case-by-case basis to use it in their reference widgets directly from the View DSL configuration.

=== Breadboarding

No UI change.

=== Cutting backs

* Make `ModelBrowserDescriptionProvider` (or parts of it) easier to reuse when creating specialized `modelBrowser://` tree descriptions.
* In particular, make it possible/easier to use tree descriptions which do not assume that the candidates displayed are EMF `EObjects` (which is one important use case for custom trees in this context).

=== Rabbit holes

* It is possible that the current behavior (notably on the front) makes somes assumptions on the feature/behavior of the `TreeDescription` used which have never been made explicit because we only ever used/tested the 2 current choices (which are almost identical except regarding which elements are selectable).

== Status

Proposed

== Consequences

